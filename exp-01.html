<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KG-R1</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #f5f5f0;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        .play-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border: 1px solid #333;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .play-btn:hover {
            background: #333;
            color: white;
        }
        
        .play-btn.playing {
            background: #333;
            color: white;
        }
        
        .viz-bar {
            position: absolute;
            bottom: 30px;
            right: 90px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 40px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .viz-bar.active {
            opacity: 1;
        }
        
        .exp-label {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            letter-spacing: 0.15em;
            color: #999;
        }
        
        .bar {
            width: 4px;
            background: #333;
            transition: height 0.1s;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <button class="play-btn" id="playBtn">▶</button>
    
    <div class="viz-bar" id="vizBar">
        <div class="bar" style="height: 10px"></div>
        <div class="bar" style="height: 20px"></div>
        <div class="bar" style="height: 15px"></div>
        <div class="bar" style="height: 25px"></div>
        <div class="bar" style="height: 18px"></div>
    </div>
    
    <div class="exp-label">emote.bot.exp(01)</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f0);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // Speaker group
        const speakerGroup = new THREE.Group();
        scene.add(speakerGroup);
        
        // Line materials
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
        const thinLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 });
        
        // Helper: wireframe box
        function createWireframeBox(w, h, d, mat, pos) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, mat);
            line.position.copy(pos);
            return line;
        }
        
        // ===== CABINET =====
        const cabW = 5.6, cabH = 10.2, cabD = 4.1;
        const cabinet = createWireframeBox(cabW, cabH, cabD, lineMaterial, new THREE.Vector3(0, 0, 0));
        speakerGroup.add(cabinet);
        
        // Baffle
        const baffle = createWireframeBox(5.2, 9.6, 0.2, thinLineMaterial, new THREE.Vector3(0, 0, cabD/2 + 0.1));
        speakerGroup.add(baffle);
        
        // ===== WOOFER =====
        const wooferY = -0.5;
        const wooferZ = cabD/2 + 0.2;
        
        // Surround
        const surroundGeo = new THREE.RingGeometry(1.3, 1.5, 64);
        const surround = new THREE.LineSegments(new THREE.EdgesGeometry(surroundGeo), lineMaterial);
        surround.position.set(0, wooferY, wooferZ);
        speakerGroup.add(surround);
        
        // Cone rings
        [0.3, 0.6, 0.9, 1.15].forEach(r => {
            const ringGeo = new THREE.RingGeometry(r - 0.02, r, 48);
            const ring = new THREE.LineSegments(new THREE.EdgesGeometry(ringGeo), thinLineMaterial);
            ring.position.set(0, wooferY, wooferZ);
            speakerGroup.add(ring);
        });
        
        // Dust cap
        const dustCapGeo = new THREE.CircleGeometry(0.35, 32);
        const dustCap = new THREE.LineSegments(new THREE.EdgesGeometry(dustCapGeo), lineMaterial);
        dustCap.position.set(0, wooferY, wooferZ);
        speakerGroup.add(dustCap);
        
        // Center dot
        const centerDotGeo = new THREE.CircleGeometry(0.05, 16);
        const centerDot = new THREE.LineSegments(new THREE.EdgesGeometry(centerDotGeo), lineMaterial);
        centerDot.position.set(0, wooferY, wooferZ + 0.01);
        speakerGroup.add(centerDot);
        
        // ===== PORT =====
        const portFrame = createWireframeBox(1.6, 0.5, 0.1, lineMaterial, new THREE.Vector3(0, -3.5, wooferZ));
        speakerGroup.add(portFrame);
        
        const portOpening = createWireframeBox(1.4, 0.4, 0.15, thinLineMaterial, new THREE.Vector3(0, -3.5, wooferZ));
        speakerGroup.add(portOpening);
        
        // ===== SCREWS =====
        [[-2.3, 4.5], [2.3, 4.5], [-2.3, -4.5], [2.3, -4.5], [-2.3, 0], [2.3, 0], [-2.3, 2.5], [2.3, 2.5], [-2.3, -2.5], [2.3, -2.5]].forEach(pos => {
            const screwGeo = new THREE.CircleGeometry(0.08, 8);
            const screw = new THREE.LineSegments(new THREE.EdgesGeometry(screwGeo), lineMaterial);
            screw.position.set(pos[0], pos[1], wooferZ + 0.02);
            speakerGroup.add(screw);
        });
        
        // ===== MULTI-CELL HORN =====
        const hornBaseY = cabH/2 + 0.5;
        const hornH = 2.0;
        
        // Horn mouth
        const hornMouth = createWireframeBox(4.8, 0.5, 3.2, lineMaterial, new THREE.Vector3(0, hornBaseY + hornH, 0));
        speakerGroup.add(hornMouth);
        
        // Horn throat
        const hornThroat = createWireframeBox(3.2, 0.5, 2.4, lineMaterial, new THREE.Vector3(0, hornBaseY, 0));
        speakerGroup.add(hornThroat);
        
        // Horn flares
        const flarePointsL = [
            new THREE.Vector3(-1.6, hornBaseY, 1.2),
            new THREE.Vector3(-2.4, hornBaseY + hornH, 1.6),
            new THREE.Vector3(-2.4, hornBaseY + hornH, -1.6),
            new THREE.Vector3(-1.6, hornBaseY, -1.2),
            new THREE.Vector3(-1.6, hornBaseY, 1.2)
        ];
        speakerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(flarePointsL), lineMaterial));
        
        const flarePointsR = [
            new THREE.Vector3(1.6, hornBaseY, 1.2),
            new THREE.Vector3(2.4, hornBaseY + hornH, 1.6),
            new THREE.Vector3(2.4, hornBaseY + hornH, -1.6),
            new THREE.Vector3(1.6, hornBaseY, -1.2),
            new THREE.Vector3(1.6, hornBaseY, 1.2)
        ];
        speakerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(flarePointsR), lineMaterial));
        
        // Horn vanes
        for (let i = 0; i <= 5; i++) {
            const t = i / 5;
            const xBot = -1.6 + t * 3.2;
            const xTop = -2.4 + t * 4.8;
            const vaneGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(xBot, hornBaseY, 0),
                new THREE.Vector3(xTop, hornBaseY + hornH, 0)
            ]);
            speakerGroup.add(new THREE.Line(vaneGeo, thinLineMaterial));
        }
        
        // Compression driver
        const driverGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16);
        const driver = new THREE.LineSegments(new THREE.EdgesGeometry(driverGeo), lineMaterial);
        driver.position.set(0, hornBaseY + hornH + 0.6, 0);
        speakerGroup.add(driver);
        
        // ===== STAND =====
        const standBaseY = -cabH/2 - 0.5;
        
        // Base
        const standBase = createWireframeBox(5.0, 0.3, 3.5, lineMaterial, new THREE.Vector3(0, standBaseY - 0.15, 0));
        speakerGroup.add(standBase);
        
        // Pillars
        const pillarGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.0, 12);
        const pillarEdges = new THREE.EdgesGeometry(pillarGeo);
        
        [[-2, 1.2], [2, 1.2], [-2, -1.2], [2, -1.2]].forEach(pos => {
            const pillar = new THREE.LineSegments(pillarEdges, lineMaterial);
            pillar.position.set(pos[0], standBaseY - 1.0, pos[1]);
            speakerGroup.add(pillar);
        });
        
        // Feet
        const footGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.15, 12);
        const footEdges = new THREE.EdgesGeometry(footGeo);
        [[-2, 1.2], [2, 1.2], [-2, -1.2], [2, -1.2]].forEach(pos => {
            const foot = new THREE.LineSegments(footEdges, lineMaterial);
            foot.position.set(pos[0], standBaseY - 2.1, pos[1]);
            speakerGroup.add(foot);
        });
        
        // ===== CONTROLS =====
        let autoRotate = true;
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        let interactionTimer = null;
        
        // Resume auto-rotate after 2 seconds of no interaction
        function resetInteractionTimer() {
            if (interactionTimer) clearTimeout(interactionTimer);
            interactionTimer = setTimeout(() => {
                autoRotate = true;
            }, 2000);
        }
        
        // Mouse drag
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            speakerGroup.rotation.y += (e.clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => {
            isDragging = false;
            resetInteractionTimer();
        });
        
        // Touch
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            speakerGroup.rotation.y += (e.touches[0].clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.touches[0].clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchend', () => {
            isDragging = false;
            resetInteractionTimer();
        });
        
        // Zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(8, Math.min(30, camera.position.z));
        });
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ===== PROCEDURAL AUDIO =====
        const playBtn = document.getElementById('playBtn');
        const vizBar = document.getElementById('vizBar');
        const bars = document.querySelectorAll('.bar');
        let isPlaying = false;
        let audioCtx = null;
        let activeNodes = [];
        let musicInterval = null;
        
        // Jazz chord voicings (frequencies for Cmaj7, Dm7, G7, etc.)
        const chords = [
            [261.63, 329.63, 392.00, 493.88], // Cmaj7
            [293.66, 349.23, 440.00, 523.25], // Dm7
            [392.00, 493.88, 587.33, 698.46], // G7
            [349.23, 440.00, 523.25, 659.25], // Fmaj7
            [220.00, 261.63, 329.63, 392.00], // A7
        ];
        
        const bassNotes = [130.81, 146.83, 98.00, 116.54, 110.00]; // C3, D3, G2, Bb2, A2
        
        function createChillJazzChord() {
            if (!audioCtx) return;
            
            const chord = chords[Math.floor(Math.random() * chords.length)];
            const bass = bassNotes[Math.floor(Math.random() * bassNotes.length)];
            
            // Create dreamy pad
            chord.forEach((freq, i) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 1;
                
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 1);
                gain.gain.exponentialRampToValueAtTime(0.02, audioCtx.currentTime + 4);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 5);
                activeNodes.push(osc, gain);
            });
            
            // Bass note
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            const bassFilter = audioCtx.createBiquadFilter();
            
            bassOsc.type = 'triangle';
            bassOsc.frequency.value = bass;
            
            bassFilter.type = 'lowpass';
            bassFilter.frequency.value = 400;
            
            bassGain.gain.setValueAtTime(0, audioCtx.currentTime);
            bassGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
            bassGain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 3);
            
            bassOsc.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            
            bassOsc.start();
            bassOsc.stop(audioCtx.currentTime + 4);
            activeNodes.push(bassOsc, bassGain);
            
            // Random melody note
            if (Math.random() > 0.6) {
                const melodyFreq = chord[Math.floor(Math.random() * chord.length)] * 2;
                const melOsc = audioCtx.createOscillator();
                const melGain = audioCtx.createGain();
                
                melOsc.type = 'sine';
                melOsc.frequency.value = melodyFreq;
                
                melGain.gain.setValueAtTime(0, audioCtx.currentTime);
                melGain.gain.linearRampToValueAtTime(0.05, audioCtx.currentTime + 0.1);
                melGain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);
                
                melOsc.connect(melGain);
                melGain.connect(audioCtx.destination);
                
                melOsc.start();
                melOsc.stop(audioCtx.currentTime + 2);
                activeNodes.push(melOsc, melGain);
            }
        }
        
        async function startMusic() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Resume audio context (required by browsers)
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            
            // Play initial chord
            createChillJazzChord();
            
            // Continue playing every 3-5 seconds
            musicInterval = setInterval(() => {
                if (isPlaying && audioCtx) {
                    createChillJazzChord();
                }
            }, 3500 + Math.random() * 2000);
        }
        
        function stopMusic() {
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
            activeNodes = [];
        }
        
        playBtn.addEventListener('click', () => {
            if (isPlaying) {
                stopMusic();
                playBtn.textContent = '▶';
                playBtn.classList.remove('playing');
                vizBar.classList.remove('active');
            } else {
                startMusic();
                playBtn.textContent = '⏸';
                playBtn.classList.add('playing');
                vizBar.classList.add('active');
            }
            isPlaying = !isPlaying;
        });
        
        // Visualizer animation
        function animateViz() {
            if (isPlaying) {
                bars.forEach(bar => {
                    bar.style.height = (8 + Math.random() * 30) + 'px';
                });
            }
            setTimeout(animateViz, 150);
        }
        animateViz();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate && !isDragging) {
                speakerGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
