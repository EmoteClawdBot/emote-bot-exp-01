<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage 1950s Speaker - Interactive 3D</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a3e 50%, #0f0f23 100%);
        }
        
        #root {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a3e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }
        
        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-text {
            color: #E76F51;
            font-size: 24px;
            font-weight: 300;
            letter-spacing: 0.2em;
            margin-top: 20px;
        }
        
        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(231, 111, 81, 0.2);
            border-top-color: #E76F51;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .controls {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 50px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 13px;
            letter-spacing: 0.05em;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .control-btn.active {
            background: rgba(231, 111, 81, 0.3);
            border-color: #E76F51;
            color: #E76F51;
        }
        
        .power-btn {
            position: fixed;
            top: 30px;
            right: 30px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: linear-gradient(145deg, #2a2a3a, #1a1a2a);
            border: 2px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 4px 15px rgba(0, 0, 0, 0.5),
                inset 0 2px 4px rgba(255, 255, 255, 0.1);
        }
        
        .power-btn:hover {
            transform: scale(1.05);
            box-shadow: 
                0 6px 20px rgba(0, 0, 0, 0.6),
                inset 0 2px 4px rgba(255, 255, 255, 0.15);
        }
        
        .power-btn.on {
            background: linear-gradient(145deg, #E76F51, #c45a3f);
            border-color: rgba(231, 111, 81, 0.5);
            box-shadow: 
                0 0 30px rgba(231, 111, 81, 0.5),
                0 0 60px rgba(231, 111, 81, 0.3),
                inset 0 2px 4px rgba(255, 255, 255, 0.2);
            animation: pulse-glow 2s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 30px rgba(231, 111, 81, 0.5), 0 0 60px rgba(231, 111, 81, 0.3), inset 0 2px 4px rgba(255, 255, 255, 0.2); }
            50% { box-shadow: 0 0 40px rgba(231, 111, 81, 0.7), 0 0 80px rgba(231, 111, 81, 0.4), inset 0 2px 4px rgba(255, 255, 255, 0.2); }
        }
        
        .info-panel {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }
        
        .info-panel h1 {
            font-size: 14px;
            font-weight: 400;
            margin-bottom: 5px;
            color: #E76F51;
        }
        
        canvas {
            display: block;
            outline: none;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        
        // Spotify playlist URL
        const SPOTIFY_PLAYLIST = 'https://open.spotify.com/playlist/0AvvFv0uHQOF2XIzF0BQGg?si=TgSfEO_nRpS4i9RIM0calQ&pi=AvWZI01oQTCGl';
        
        const VintageSpeaker = () => {
            const mountRef = useRef(null);
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const rendererRef = useRef(null);
            const controlsRef = useRef(null);
            const speakerGroupRef = useRef(null);
            const materialsRef = useRef({});
            const lightsRef = useRef({});
            const animationRef = useRef(null);
            const spotifyOpened = useRef(false);
            
            const [isLoading, setIsLoading] = useState(true);
            const [isPowered, setIsPowered] = useState(false);
            const [autoRotate, setAutoRotate] = useState(false);
            
            // Initialize Three.js scene
            useEffect(() => {
                const init = () => {
                    // Scene
                    const scene = new THREE.Scene();
                    scene.fog = new THREE.FogExp2(0x0a0a1a, 0.02);
                    sceneRef.current = scene;
                    
                    // Camera
                    const camera = new THREE.PerspectiveCamera(
                        45,
                        window.innerWidth / window.innerHeight,
                        0.1,
                        1000
                    );
                    camera.position.set(8, 4, 8);
                    cameraRef.current = camera;
                    
                    // Renderer
                    const renderer = new THREE.WebGLRenderer({
                        antialias: true,
                        alpha: true,
                        powerPreference: 'high-performance'
                    });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.2;
                    renderer.outputEncoding = THREE.sRGBEncoding;
                    mountRef.current.appendChild(renderer.domElement);
                    rendererRef.current = renderer;
                    
                    // Controls
                    const controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.minDistance = 4;
                    controls.maxDistance = 15;
                    controls.maxPolarAngle = Math.PI / 2 - 0.1;
                    controls.autoRotate = false;
                    controls.autoRotateSpeed = 1.0;
                    controlsRef.current = controls;
                    
                    // Create speaker
                    createSpeaker(scene);
                    
                    // Create lights
                    createLights(scene);
                    
                    // Create ground reflection
                    createGround(scene);
                    
                    // Handle resize
                    const handleResize = () => {
                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(window.innerWidth, window.innerHeight);
                    };
                    window.addEventListener('resize', handleResize);
                    
                    // Animation loop
                    const animate = () => {
                        animationRef.current = requestAnimationFrame(animate);
                        
                        if (controlsRef.current) {
                            controlsRef.current.update();
                        }
                        
                        // Pulse effect when powered on
                        if (isPowered && materialsRef.current.hornEmissive) {
                            const time = Date.now() * 0.002;
                            const intensity = 0.5 + Math.sin(time) * 0.3;
                            materialsRef.current.hornEmissive.intensity = intensity;
                        }
                        
                        renderer.render(scene, camera);
                    };
                    animate();
                    
                    // Simulate loading
                    setTimeout(() => {
                        setIsLoading(false);
                    }, 2000);
                    
                    return () => {
                        window.removeEventListener('resize', handleResize);
                        cancelAnimationFrame(animationRef.current);
                        renderer.dispose();
                    };
                };
                
                init();
            }, []);
            
            // Create the speaker model
            const createSpeaker = (scene) => {
                const speakerGroup = new THREE.Group();
                speakerGroupRef.current = speakerGroup;
                
                // Materials
                const cabinetMaterial = new THREE.MeshStandardMaterial({
                    color: 0xE76F51,
                    roughness: 0.7,
                    metalness: 0.1,
                    bumpScale: 0.02
                });
                
                const chromeMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.1,
                    metalness: 0.95,
                    envMapIntensity: 1.5
                });
                
                const speakerConeMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    roughness: 0.6,
                    metalness: 0.2
                });
                
                const hornEmissiveMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffaa44,
                    emissive: 0xff6600,
                    emissiveIntensity: 0,
                    roughness: 0.4,
                    metalness: 0.1
                });
                materialsRef.current.hornEmissive = hornEmissiveMaterial;
                
                // Main cabinet - tapered design
                const cabinetGeometry = new THREE.BoxGeometry(3, 4.5, 2.5);
                // Taper the top
                const cabinetPositions = cabinetGeometry.attributes.position;
                for (let i = 0; i < cabinetPositions.count; i++) {
                    const y = cabinetPositions.getY(i);
                    if (y > 0) {
                        const x = cabinetPositions.getX(i);
                        const z = cabinetPositions.getZ(i);
                        cabinetPositions.setX(i, x * 0.85);
                        cabinetPositions.setZ(i, z * 0.85);
                    }
                }
                cabinetGeometry.computeVertexNormals();
                
                const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
                cabinet.position.y = 0;
                cabinet.castShadow = true;
                cabinet.receiveShadow = true;
                speakerGroup.add(cabinet);
                
                // Speaker cone cutout area
                const coneFrameGeometry = new THREE.RingGeometry(0.8, 1.2, 32);
                const coneFrame = new THREE.Mesh(coneFrameGeometry, cabinetMaterial);
                coneFrame.position.set(0, -0.5, 1.26);
                speakerGroup.add(coneFrame);
                
                // Speaker cone
                const coneGeometry = new THREE.ConeGeometry(0.9, 0.6, 32, 1, true);
                const cone = new THREE.Mesh(coneGeometry, speakerConeMaterial);
                cone.position.set(0, -0.5, 1.1);
                cone.rotation.x = Math.PI;
                speakerGroup.add(cone);
                
                // Dust cap
                const dustCapGeometry = new THREE.SphereGeometry(0.35, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const dustCap = new THREE.Mesh(dustCapGeometry, new THREE.MeshStandardMaterial({
                    color: 0xE76F51,
                    roughness: 0.5
                }));
                dustCap.position.set(0, -0.5, 1.35);
                dustCap.rotation.x = Math.PI;
                speakerGroup.add(dustCap);
                
                // Bass port
                const portGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 32);
                const port = new THREE.Mesh(portGeometry, new THREE.MeshStandardMaterial({
                    color: 0x0a0a0a,
                    roughness: 0.9
                }));
                port.position.set(0, -1.8, 1.26);
                speakerGroup.add(port);
                
                // Chrome horn speaker on top
                const hornBaseGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.3, 32);
                const hornBase = new THREE.Mesh(hornBaseGeometry, chromeMaterial);
                hornBase.position.set(0, 2.5, 0);
                speakerGroup.add(hornBase);
                
                // Horn flare
                const hornGeometry = new THREE.CylinderGeometry(1.2, 0.6, 1.5, 32, 1, true);
                const horn = new THREE.Mesh(hornGeometry, chromeMaterial);
                horn.position.set(0, 3.2, 0);
                speakerGroup.add(horn);
                
                // Horn interior (emissive when on)
                const hornInteriorGeometry = new THREE.ConeGeometry(1.0, 1.0, 32, 1, true);
                const hornInterior = new THREE.Mesh(hornInteriorGeometry, hornEmissiveMaterial);
                hornInterior.position.set(0, 3.0, 0);
                hornInterior.rotation.x = Math.PI;
                speakerGroup.add(hornInterior);
                
                // Control box on top
                const controlBoxGeometry = new THREE.BoxGeometry(1.2, 0.4, 0.8);
                const controlBox = new THREE.Mesh(controlBoxGeometry, chromeMaterial);
                controlBox.position.set(0, 2.3, 0.5);
                speakerGroup.add(controlBox);
                
                // Knobs on control box
                const knobGeometry = new THREE.CylinderGeometry(0.12, 0.12, 0.15, 16);
                const knobMaterial = new THREE.MeshStandardMaterial({
                    color: 0x1a1a1a,
                    roughness: 0.3,
                    metalness: 0.8
                });
                
                const knob1 = new THREE.Mesh(knobGeometry, knobMaterial);
                knob1.position.set(-0.3, 2.5, 0.5);
                speakerGroup.add(knob1);
                
                const knob2 = new THREE.Mesh(knobGeometry, knobMaterial);
                knob2.position.set(0.3, 2.5, 0.5);
                speakerGroup.add(knob2);
                
                // Speaker feet
                const footGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.2, 16);
                const footMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2a2a2a,
                    roughness: 0.8
                });
                
                const positions = [
                    [-1.2, -2.35, -1],
                    [1.2, -2.35, -1],
                    [-1.2, -2.35, 1],
                    [1.2, -2.35, 1]
                ];
                
                positions.forEach(pos => {
                    const foot = new THREE.Mesh(footGeometry, footMaterial);
                    foot.position.set(...pos);
                    speakerGroup.add(foot);
                });
                
                // Add subtle wear/grain texture effect using noise
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#E76F51';
                ctx.fillRect(0, 0, 512, 512);
                
                // Add noise
                for (let i = 0; i < 50000; i++) {
                    ctx.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.05})`;
                    ctx.fillRect(Math.random() * 512, Math.random() * 512, 2, 2);
                }
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;
                cabinetMaterial.map = texture;
                
                scene.add(speakerGroup);
            };
            
            // Create lighting setup
            const createLights = (scene) => {
                // Key light (upper right, soft)
                const keyLight = new THREE.SpotLight(0xffffff, 1.5);
                keyLight.position.set(10, 12, 8);
                keyLight.angle = Math.PI / 6;
                keyLight.penumbra = 0.3;
                keyLight.decay = 2;
                keyLight.distance = 50;
                keyLight.castShadow = true;
                keyLight.shadow.mapSize.width = 2048;
                keyLight.shadow.mapSize.height = 2048;
                scene.add(keyLight);
                lightsRef.current.keyLight = keyLight;
                
                // Rim light (back, defines edges)
                const rimLight = new THREE.SpotLight(0x4455ff, 0.8);
                rimLight.position.set(-8, 6, -8);
                rimLight.lookAt(0, 0, 0);
                scene.add(rimLight);
                
                // Fill light (soft ambient from left)
                const fillLight = new THREE.DirectionalLight(0xffccaa, 0.4);
                fillLight.position.set(-5, 4, 5);
                scene.add(fillLight);
                
                // Ambient
                const ambientLight = new THREE.AmbientLight(0x1a1a3a, 0.3);
                scene.add(ambientLight);
                
                // Warm glow from horn when powered
                const hornLight = new THREE.PointLight(0xff6600, 0, 10);
                hornLight.position.set(0, 4, 0);
                scene.add(hornLight);
                lightsRef.current.hornLight = hornLight;
            };
            
            // Create reflective ground
            const createGround = (scene) => {
                const groundGeometry = new THREE.PlaneGeometry(50, 50);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: 0x0a0a1a,
                    roughness: 0.1,
                    metalness: 0.5
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -3;
                ground.receiveShadow = true;
                scene.add(ground);
            };
            
            // Toggle power
            const togglePower = useCallback(() => {
                setIsPowered(prev => {
                    const newState = !prev;
                    
                    if (newState) {
                        // Turn on
                        if (materialsRef.current.hornEmissive) {
                            materialsRef.current.hornEmissive.emissiveIntensity = 0.8;
                        }
                        if (lightsRef.current.hornLight) {
                            lightsRef.current.hornLight.intensity = 2;
                        }
                        
                        // Open Spotify on first activation
                        if (!spotifyOpened.current) {
                            setTimeout(() => {
                                window.open(SPOTIFY_PLAYLIST, '_blank');
                                spotifyOpened.current = true;
                            }, 500);
                        }
                    } else {
                        // Turn off
                        if (materialsRef.current.hornEmissive) {
                            materialsRef.current.hornEmissive.emissiveIntensity = 0;
                        }
                        if (lightsRef.current.hornLight) {
                            lightsRef.current.hornLight.intensity = 0;
                        }
                    }
                    
                    return newState;
                });
            }, []);
            
            // Toggle auto-rotate
            const toggleAutoRotate = useCallback(() => {
                setAutoRotate(prev => {
                    const newState = !prev;
                    if (controlsRef.current) {
                        controlsRef.current.autoRotate = newState;
                    }
                    return newState;
                });
            }, []);
            
            return (
                <>
                    {/* Loading Screen */}
                    <div className={`loading-screen ${!isLoading ? 'hidden' : ''}`}>
                        <div className="loading-spinner"></div>
                        <div className="loading-text">INITIALIZING AUDIO SYSTEM</div>
                    </div>
                    
                    {/* Info Panel */}
                    <div className="info-panel">
                        <h1>Vintage Audio 1950</h1>
                        <div>Interactive 3D Experience</div>
                    </div>
                    
                    {/* Power Button */}
                    <button 
                        className={`power-btn ${isPowered ? 'on' : ''}`}
                        onClick={togglePower}
                        aria-label="Toggle Power"
                    >
                        {isPowered ? 'üîä' : 'üîá'}
                    </button>
                    
                    {/* Controls */}
                    <div className="controls">
                        <button 
                            className={`control-btn ${autoRotate ? 'active' : ''}`}
                            onClick={toggleAutoRotate}
                        >
                            {autoRotate ? '‚èπ Stop' : '‚ñ∂ Rotate'}
                        </button>
                        <button className="control-btn" onClick={() => {
                            if (controlsRef.current) {
                                controlsRef.current.reset();
                            }
                        }}>
                            ‚ü≤ Reset View
                        </button>
                    </div>
                    
                    {/* 3D Canvas */}
                    <div ref={mountRef} style={{ width: '100%', height: '100%' }} />
                </>
            );
        };
        
        ReactDOM.render(<VintageSpeaker />, document.getElementById('root'));
    </script>
</body>
</html>
