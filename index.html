<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KG-R1</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #f5f5f0;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        .play-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border: 1px solid #333;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .play-btn:hover {
            background: #333;
            color: white;
        }
        
        .play-btn.playing {
            background: #333;
            color: white;
        }
        
        .viz-bar {
            position: absolute;
            bottom: 30px;
            right: 90px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 40px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .viz-bar.active {
            opacity: 1;
        }
        
        .exp-label {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            letter-spacing: 0.15em;
            color: #999;
        }
        
        .bar {
            width: 4px;
            background: #333;
            transition: height 0.1s;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <button class="play-btn" id="playBtn">▶</button>
    
    <div class="viz-bar" id="vizBar">
        <div class="bar" style="height: 10px"></div>
        <div class="bar" style="height: 20px"></div>
        <div class="bar" style="height: 15px"></div>
        <div class="bar" style="height: 25px"></div>
        <div class="bar" style="height: 18px"></div>
    </div>
    
    <div class="exp-label">emote.bot.exp(01)</div>
    
    <audio id="audio" loop crossorigin="anonymous">
        <source src="https://files.freemusicarchive.org/storage-freemusicarchive-org/music/ccCommunity/Chad_Crouch/Arps/Chad_Crouch_-_Elisions.mp3" type="audio/mpeg">
    </audio>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f0);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // Speaker group
        const speakerGroup = new THREE.Group();
        scene.add(speakerGroup);
        
        // Line materials
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
        const thinLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 });
        
        // Helper: wireframe box
        function createWireframeBox(w, h, d, mat, pos) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, mat);
            line.position.copy(pos);
            return line;
        }
        
        // ===== CABINET =====
        const cabW = 5.6, cabH = 10.2, cabD = 4.1;
        const cabinet = createWireframeBox(cabW, cabH, cabD, lineMaterial, new THREE.Vector3(0, 0, 0));
        speakerGroup.add(cabinet);
        
        // Baffle
        const baffle = createWireframeBox(5.2, 9.6, 0.2, thinLineMaterial, new THREE.Vector3(0, 0, cabD/2 + 0.1));
        speakerGroup.add(baffle);
        
        // ===== WOOFER =====
        const wooferY = -0.5;
        const wooferZ = cabD/2 + 0.2;
        
        // Surround
        const surroundGeo = new THREE.RingGeometry(1.3, 1.5, 64);
        const surround = new THREE.LineSegments(new THREE.EdgesGeometry(surroundGeo), lineMaterial);
        surround.position.set(0, wooferY, wooferZ);
        speakerGroup.add(surround);
        
        // Cone rings
        [0.3, 0.6, 0.9, 1.15].forEach(r => {
            const ringGeo = new THREE.RingGeometry(r - 0.02, r, 48);
            const ring = new THREE.LineSegments(new THREE.EdgesGeometry(ringGeo), thinLineMaterial);
            ring.position.set(0, wooferY, wooferZ);
            speakerGroup.add(ring);
        });
        
        // Dust cap
        const dustCapGeo = new THREE.CircleGeometry(0.35, 32);
        const dustCap = new THREE.LineSegments(new THREE.EdgesGeometry(dustCapGeo), lineMaterial);
        dustCap.position.set(0, wooferY, wooferZ);
        speakerGroup.add(dustCap);
        
        // Center dot
        const centerDotGeo = new THREE.CircleGeometry(0.05, 16);
        const centerDot = new THREE.LineSegments(new THREE.EdgesGeometry(centerDotGeo), lineMaterial);
        centerDot.position.set(0, wooferY, wooferZ + 0.01);
        speakerGroup.add(centerDot);
        
        // ===== PORT =====
        const portFrame = createWireframeBox(1.6, 0.5, 0.1, lineMaterial, new THREE.Vector3(0, -3.5, wooferZ));
        speakerGroup.add(portFrame);
        
        const portOpening = createWireframeBox(1.4, 0.4, 0.15, thinLineMaterial, new THREE.Vector3(0, -3.5, wooferZ));
        speakerGroup.add(portOpening);
        
        // ===== SCREWS =====
        [[-2.3, 4.5], [2.3, 4.5], [-2.3, -4.5], [2.3, -4.5], [-2.3, 0], [2.3, 0], [-2.3, 2.5], [2.3, 2.5], [-2.3, -2.5], [2.3, -2.5]].forEach(pos => {
            const screwGeo = new THREE.CircleGeometry(0.08, 8);
            const screw = new THREE.LineSegments(new THREE.EdgesGeometry(screwGeo), lineMaterial);
            screw.position.set(pos[0], pos[1], wooferZ + 0.02);
            speakerGroup.add(screw);
        });
        
        // ===== MULTI-CELL HORN =====
        const hornBaseY = cabH/2 + 0.5;
        const hornH = 2.0;
        
        // Horn mouth
        const hornMouth = createWireframeBox(4.8, 0.5, 3.2, lineMaterial, new THREE.Vector3(0, hornBaseY + hornH, 0));
        speakerGroup.add(hornMouth);
        
        // Horn throat
        const hornThroat = createWireframeBox(3.2, 0.5, 2.4, lineMaterial, new THREE.Vector3(0, hornBaseY, 0));
        speakerGroup.add(hornThroat);
        
        // Horn flares
        const flarePointsL = [
            new THREE.Vector3(-1.6, hornBaseY, 1.2),
            new THREE.Vector3(-2.4, hornBaseY + hornH, 1.6),
            new THREE.Vector3(-2.4, hornBaseY + hornH, -1.6),
            new THREE.Vector3(-1.6, hornBaseY, -1.2),
            new THREE.Vector3(-1.6, hornBaseY, 1.2)
        ];
        speakerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(flarePointsL), lineMaterial));
        
        const flarePointsR = [
            new THREE.Vector3(1.6, hornBaseY, 1.2),
            new THREE.Vector3(2.4, hornBaseY + hornH, 1.6),
            new THREE.Vector3(2.4, hornBaseY + hornH, -1.6),
            new THREE.Vector3(1.6, hornBaseY, -1.2),
            new THREE.Vector3(1.6, hornBaseY, 1.2)
        ];
        speakerGroup.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(flarePointsR), lineMaterial));
        
        // Horn vanes
        for (let i = 0; i <= 5; i++) {
            const t = i / 5;
            const xBot = -1.6 + t * 3.2;
            const xTop = -2.4 + t * 4.8;
            const vaneGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(xBot, hornBaseY, 0),
                new THREE.Vector3(xTop, hornBaseY + hornH, 0)
            ]);
            speakerGroup.add(new THREE.Line(vaneGeo, thinLineMaterial));
        }
        
        // Compression driver
        const driverGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.8, 16);
        const driver = new THREE.LineSegments(new THREE.EdgesGeometry(driverGeo), lineMaterial);
        driver.position.set(0, hornBaseY + hornH + 0.6, 0);
        speakerGroup.add(driver);
        
        // ===== STAND =====
        const standBaseY = -cabH/2 - 0.5;
        
        // Base
        const standBase = createWireframeBox(5.0, 0.3, 3.5, lineMaterial, new THREE.Vector3(0, standBaseY - 0.15, 0));
        speakerGroup.add(standBase);
        
        // Pillars
        const pillarGeo = new THREE.CylinderGeometry(0.15, 0.15, 2.0, 12);
        const pillarEdges = new THREE.EdgesGeometry(pillarGeo);
        
        [[-2, 1.2], [2, 1.2], [-2, -1.2], [2, -1.2]].forEach(pos => {
            const pillar = new THREE.LineSegments(pillarEdges, lineMaterial);
            pillar.position.set(pos[0], standBaseY - 1.0, pos[1]);
            speakerGroup.add(pillar);
        });
        
        // Feet
        const footGeo = new THREE.CylinderGeometry(0.2, 0.25, 0.15, 12);
        const footEdges = new THREE.EdgesGeometry(footGeo);
        [[-2, 1.2], [2, 1.2], [-2, -1.2], [2, -1.2]].forEach(pos => {
            const foot = new THREE.LineSegments(footEdges, lineMaterial);
            foot.position.set(pos[0], standBaseY - 2.1, pos[1]);
            speakerGroup.add(foot);
        });
        
        // ===== CONTROLS =====
        let autoRotate = true;
        
        // Mouse drag
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            speakerGroup.rotation.y += (e.clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        
        // Touch
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            speakerGroup.rotation.y += (e.touches[0].clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.touches[0].clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchend', () => isDragging = false);
        
        // Zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(8, Math.min(30, camera.position.z));
        });
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ===== AUDIO =====
        const audio = document.getElementById('audio');
        const playBtn = document.getElementById('playBtn');
        const vizBar = document.getElementById('vizBar');
        const bars = document.querySelectorAll('.bar');
        let isPlaying = false;
        
        playBtn.addEventListener('click', () => {
            if (isPlaying) {
                audio.pause();
                playBtn.textContent = '▶';
                playBtn.classList.remove('playing');
                vizBar.classList.remove('active');
            } else {
                audio.play();
                playBtn.textContent = '⏸';
                playBtn.classList.add('playing');
                vizBar.classList.add('active');
            }
            isPlaying = !isPlaying;
        });
        
        // Visualizer animation
        function animateViz() {
            if (isPlaying) {
                bars.forEach(bar => {
                    bar.style.height = (10 + Math.random() * 25) + 'px';
                });
            }
            setTimeout(animateViz, 100);
        }
        animateViz();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate && !isDragging) {
                speakerGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
