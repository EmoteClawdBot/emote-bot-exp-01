<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Speaker</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            overflow: hidden;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 15, 40);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 1, 14);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // ===== LIGHTING =====
        // Ambient - very subtle
        scene.add(new THREE.AmbientLight(0x1a1a2e, 0.2));
        
        // Key light - warm, from upper right
        const keyLight = new THREE.SpotLight(0xffecd1, 2);
        keyLight.position.set(8, 12, 10);
        keyLight.castShadow = true;
        keyLight.shadow.mapSize.width = 2048;
        keyLight.shadow.mapSize.height = 2048;
        keyLight.shadow.bias = -0.0001;
        keyLight.penumbra = 0.3;
        scene.add(keyLight);
        
        // Fill light - cool, from left
        const fillLight = new THREE.DirectionalLight(0x4a5568, 0.5);
        fillLight.position.set(-10, 4, 8);
        scene.add(fillLight);
        
        // Rim light - warm, from behind
        const rimLight = new THREE.SpotLight(0xffa07a, 1.5);
        rimLight.position.set(0, 8, -10);
        scene.add(rimLight);
        
        // Bottom glow - subtle bounce
        const bounceLight = new THREE.DirectionalLight(0x2d3748, 0.3);
        bounceLight.position.set(0, -5, 5);
        scene.add(bounceLight);
        
        // ===== MATERIALS =====
        const cabinetMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x8b3a2f,
            roughness: 0.6,
            metalness: 0.1,
            clearcoat: 0.2,
            clearcoatRoughness: 0.4
        });
        
        const frameMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.4,
            metalness: 0.6
        });
        
        const surroundMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x0a0a0a,
            roughness: 0.7,
            metalness: 0.0,
            clearcoat: 0.1
        });
        
        const coneMaterial = new THREE.MeshStandardMaterial({
            color: 0x1f1f1f,
            roughness: 0.85,
            metalness: 0.0
        });
        
        const dustCapMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x0f0f0f,
            roughness: 0.3,
            metalness: 0.1,
            clearcoat: 0.4
        });
        
        const wireMaterial = new THREE.MeshStandardMaterial({
            color: 0xc0c0c0,
            roughness: 0.2,
            metalness: 0.9
        });
        
        const screwMaterial = new THREE.MeshStandardMaterial({
            color: 0xe0e0e0,
            roughness: 0.15,
            metalness: 0.95
        });
        
        // ===== SPEAKER =====
        const speakerGroup = new THREE.Group();
        scene.add(speakerGroup);
        
        const cabW = 5.5, cabH = 7.5, cabD = 3;
        const frontZ = 1.6;
        const wooferY = 0;
        
        // Cabinet
        const cabinet = new THREE.Mesh(
            new THREE.BoxGeometry(cabW, cabH, cabD),
            cabinetMaterial
        );
        cabinet.castShadow = true;
        cabinet.receiveShadow = true;
        speakerGroup.add(cabinet);
        
        // Frame
        const frame = new THREE.Mesh(
            new THREE.TorusGeometry(2.3, 0.12, 16, 64),
            frameMaterial
        );
        frame.position.set(0, wooferY, frontZ);
        frame.castShadow = true;
        speakerGroup.add(frame);
        
        // Surround
        const surround = new THREE.Mesh(
            new THREE.TorusGeometry(2.1, 0.15, 16, 64),
            surroundMaterial
        );
        surround.position.set(0, wooferY, frontZ + 0.1);
        surround.castShadow = true;
        speakerGroup.add(surround);
        
        // Cone
        const cone = new THREE.Mesh(
            new THREE.CylinderGeometry(0.9, 1.9, 0.5, 64, 1, true),
            coneMaterial
        );
        cone.rotation.x = Math.PI / 2;
        cone.position.set(0, wooferY, frontZ - 0.05);
        cone.castShadow = true;
        speakerGroup.add(cone);
        
        // Cone ribs
        for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            const rib = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.7, 6),
                new THREE.MeshStandardMaterial({ color: 0x151515, roughness: 0.9 })
            );
            rib.rotation.x = Math.PI / 2;
            rib.rotation.z = angle;
            rib.position.set(
                Math.cos(angle) * 1.3,
                wooferY + Math.sin(angle) * 1.3,
                frontZ - 0.05
            );
            speakerGroup.add(rib);
        }
        
        // Dust Cap
        const dustCap = new THREE.Mesh(
            new THREE.SphereGeometry(0.8, 48, 24, 0, Math.PI * 2, 0, Math.PI / 2),
            dustCapMaterial
        );
        dustCap.rotation.x = Math.PI / 2;
        dustCap.position.set(0, wooferY, frontZ + 0.15);
        dustCap.castShadow = true;
        speakerGroup.add(dustCap);
        
        // Wire Leads
        const wire1 = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8),
            wireMaterial
        );
        wire1.rotation.z = Math.PI / 2;
        wire1.rotation.y = -0.3;
        wire1.position.set(-0.35, wooferY + 0.25, frontZ + 0.22);
        speakerGroup.add(wire1);
        
        const wire2 = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.025, 0.35, 8),
            wireMaterial
        );
        wire2.rotation.z = Math.PI / 2;
        wire2.rotation.y = 0.3;
        wire2.position.set(0.35, wooferY - 0.25, frontZ + 0.22);
        speakerGroup.add(wire2);
        
        // 4 Screws
        const screwAngles = [Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4, 7 * Math.PI / 4];
        screwAngles.forEach(angle => {
            const sx = Math.cos(angle) * 2.7;
            const sy = wooferY + Math.sin(angle) * 2.7;
            const screw = new THREE.Mesh(
                new THREE.CylinderGeometry(0.065, 0.065, 0.06, 8),
                screwMaterial
            );
            screw.rotation.x = Math.PI / 2;
            screw.position.set(sx, sy, frontZ + 0.05);
            screw.castShadow = true;
            speakerGroup.add(screw);
        });
        
        // ===== REFLECTIVE FLOOR =====
        const floorGeo = new THREE.PlaneGeometry(60, 60);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x050505,
            roughness: 0.05,
            metalness: 0.6
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -cabH / 2 - 0.5;
        floor.receiveShadow = true;
        scene.add(floor);
        
        // ===== BACKGROUND GRADIENT =====
        // Create a large sphere with gradient shader
        const vertexShader = `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;
        
        const fragmentShader = `
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + vec3(0, 20.0, 0)).y;
                vec3 topColor = vec3(0.15, 0.15, 0.18);
                vec3 bottomColor = vec3(0.04, 0.04, 0.05);
                gl_FragColor = vec4(mix(bottomColor, topColor, max(0.0, h)), 1.0);
            }
        `;
        
        const bgGeo = new THREE.SphereGeometry(50, 32, 32);
        const bgMat = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            side: THREE.BackSide
        });
        const bgSphere = new THREE.Mesh(bgGeo, bgMat);
        scene.add(bgSphere);
        
        // ===== CONTROLS =====
        let autoRotate = true;
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        
        renderer.domElement.addEventListener('mousedown', e => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', e => {
            if (!isDragging) return;
            speakerGroup.rotation.y += (e.clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        
        renderer.domElement.addEventListener('wheel', e => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(8, Math.min(20, camera.position.z));
        });
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Animation
        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate && !isDragging) speakerGroup.rotation.y += 0.002;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>