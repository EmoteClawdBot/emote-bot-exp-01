<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KG-R1</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #f5f5f0;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        .play-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 50px;
            height: 50px;
            border: 1px solid #333;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
            z-index: 100;
        }
        
        .play-btn:hover {
            background: #333;
            color: white;
        }
        
        .play-btn.playing {
            background: #333;
            color: white;
        }
        
        .viz-bar {
            position: absolute;
            bottom: 30px;
            right: 90px;
            display: flex;
            align-items: flex-end;
            gap: 3px;
            height: 40px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .viz-bar.active {
            opacity: 1;
        }
        
        .exp-label {
            position: absolute;
            bottom: 30px;
            left: 30px;
            font-family: 'Courier New', monospace;
            font-size: 9px;
            letter-spacing: 0.15em;
            color: #999;
        }
        
        .bar {
            width: 4px;
            background: #333;
            transition: height 0.1s;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <button class="play-btn" id="playBtn">▶</button>
    
    <div class="viz-bar" id="vizBar">
        <div class="bar" style="height: 10px"></div>
        <div class="bar" style="height: 20px"></div>
        <div class="bar" style="height: 15px"></div>
        <div class="bar" style="height: 25px"></div>
        <div class="bar" style="height: 18px"></div>
    </div>
    
    <div class="exp-label">emote.bot.exp(02)</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf5f5f0);
        
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 16);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        // Speaker group
        const speakerGroup = new THREE.Group();
        scene.add(speakerGroup);
        
        // Line materials
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
        const thinLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 });
        
        // Helper: wireframe box
        function createWireframeBox(w, h, d, mat, pos) {
            const geo = new THREE.BoxGeometry(w, h, d);
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, mat);
            line.position.copy(pos);
            return line;
        }
        
        // ===== CABINET (Reduced height, no horn, no stand) =====
        const cabW = 5.5, cabH = 8.5, cabD = 4.0;
        const cabinet = createWireframeBox(cabW, cabH, cabD, lineMaterial, new THREE.Vector3(0, 0, 0));
        speakerGroup.add(cabinet);
        
        const frontZ = cabD/2 + 0.1;
        const rearZ = -cabD/2 - 0.1;
        
        // ===== LARGE WOOFER (Center) =====
        const wooferY = 0;
        const wooferRadius = 2.2;
        
        // Outer frame
        const wooferFrameGeo = new THREE.CircleGeometry(wooferRadius, 48);
        const wooferFrame = new THREE.LineSegments(new THREE.EdgesGeometry(wooferFrameGeo), lineMaterial);
        wooferFrame.position.set(0, wooferY, frontZ + 0.05);
        speakerGroup.add(wooferFrame);
        
        // Surround (outer ring)
        const surroundGeo = new THREE.CircleGeometry(wooferRadius - 0.15, 48);
        const surround = new THREE.LineSegments(new THREE.EdgesGeometry(surroundGeo), lineMaterial);
        surround.position.set(0, wooferY, frontZ + 0.08);
        speakerGroup.add(surround);
        
        // Cone edge
        const coneEdgeGeo = new THREE.CircleGeometry(wooferRadius - 0.35, 48);
        const coneEdge = new THREE.LineSegments(new THREE.EdgesGeometry(coneEdgeGeo), lineMaterial);
        coneEdge.position.set(0, wooferY, frontZ + 0.02);
        speakerGroup.add(coneEdge);
        
        // Inner cone ring
        const innerConeGeo = new THREE.CircleGeometry(wooferRadius - 0.7, 36);
        const innerCone = new THREE.LineSegments(new THREE.EdgesGeometry(innerConeGeo), thinLineMaterial);
        innerCone.position.set(0, wooferY, frontZ + 0.04);
        speakerGroup.add(innerCone);
        
        // Dust cap (center dome)
        const dustCapRadius = 0.7;
        const dustCapGeo = new THREE.CircleGeometry(dustCapRadius, 24);
        const dustCap = new THREE.LineSegments(new THREE.EdgesGeometry(dustCapGeo), lineMaterial);
        dustCap.position.set(0, wooferY, frontZ + 0.12);
        speakerGroup.add(dustCap);
        
        // Dust cap detail ring
        const dustCapRingGeo = new THREE.CircleGeometry(dustCapRadius - 0.15, 24);
        const dustCapRing = new THREE.LineSegments(new THREE.EdgesGeometry(dustCapRingGeo), thinLineMaterial);
        dustCapRing.position.set(0, wooferY, frontZ + 0.13);
        speakerGroup.add(dustCapRing);
        
        // Woofer depth lines removed per request
        
        // ===== 4 SCREWS AROUND WOOFER =====
        // Positioned at corners around the woofer circle
        const screwRadius = wooferRadius + 0.4;
        const screwAngles = [Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4]; // 45°, 135°, 225°, 315°
        
        screwAngles.forEach(angle => {
            const sx = Math.cos(angle) * screwRadius;
            const sy = wooferY + Math.sin(angle) * screwRadius;
            
            // Screw head (20% smaller - 0.12 -> 0.096 ≈ 0.1)
            const screwGeo = new THREE.CircleGeometry(0.096, 8);
            const screw = new THREE.LineSegments(new THREE.EdgesGeometry(screwGeo), lineMaterial);
            screw.position.set(sx, sy, frontZ + 0.02);
            speakerGroup.add(screw);
            
            // Cross pattern (20% smaller - 0.08 -> 0.064 ≈ 0.065)
            const crossSize = 0.064;
            const crossGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(sx - crossSize, sy, frontZ + 0.03),
                new THREE.Vector3(sx + crossSize, sy, frontZ + 0.03),
                new THREE.Vector3(sx, sy - crossSize, frontZ + 0.03),
                new THREE.Vector3(sx, sy + crossSize, frontZ + 0.03)
            ]);
            speakerGroup.add(new THREE.LineSegments(crossGeo, lineMaterial));
        });
        
        // ===== REAR PANEL =====
        
        // Terminal plate
        const termPlate = createWireframeBox(1.8, 1.2, 0.1, lineMaterial, new THREE.Vector3(0, 0, rearZ));
        speakerGroup.add(termPlate);
        
        // Binding posts
        const postGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.25, 12);
        const postEdges = new THREE.EdgesGeometry(postGeo);
        
        const postPos = new THREE.LineSegments(postEdges, lineMaterial);
        postPos.position.set(-0.4, 0.1, rearZ - 0.15);
        speakerGroup.add(postPos);
        
        const postNeg = new THREE.LineSegments(postEdges, lineMaterial);
        postNeg.position.set(0.4, 0.1, rearZ - 0.15);
        speakerGroup.add(postNeg);
        
        // Terminal washers
        const washerGeo = new THREE.CircleGeometry(0.15, 12);
        const washerPos = new THREE.LineSegments(new THREE.EdgesGeometry(washerGeo), lineMaterial);
        washerPos.position.set(-0.4, 0.1, rearZ - 0.05);
        speakerGroup.add(washerPos);
        
        const washerNeg = new THREE.LineSegments(new THREE.EdgesGeometry(washerGeo), lineMaterial);
        washerNeg.position.set(0.4, 0.1, rearZ - 0.05);
        speakerGroup.add(washerNeg);
        
        // KG-R1 Badge
        const badgeFrame = createWireframeBox(1.2, 0.5, 0.05, lineMaterial, new THREE.Vector3(0, -3.5, rearZ));
        speakerGroup.add(badgeFrame);
        
        // Badge lines
        const badgeLine1 = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-0.4, -3.4, rearZ + 0.03),
            new THREE.Vector3(0.4, -3.4, rearZ + 0.03)
        ]);
        speakerGroup.add(new THREE.Line(badgeLine1, thinLineMaterial));
        
        const badgeLine2 = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-0.3, -3.6, rearZ + 0.03),
            new THREE.Vector3(0.3, -3.6, rearZ + 0.03)
        ]);
        speakerGroup.add(new THREE.Line(badgeLine2, thinLineMaterial));
        
        // Rear screws removed per request
        
        // ===== CONTROLS =====
        let autoRotate = true;
        
        let isDragging = false;
        let previousMouse = { x: 0, y: 0 };
        
        renderer.domElement.addEventListener('mousedown', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            speakerGroup.rotation.y += (e.clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.clientX, y: e.clientY };
        });
        
        renderer.domElement.addEventListener('mouseup', () => isDragging = false);
        
        // Touch
        renderer.domElement.addEventListener('touchstart', (e) => {
            isDragging = true;
            autoRotate = false;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            e.preventDefault();
            speakerGroup.rotation.y += (e.touches[0].clientX - previousMouse.x) * 0.01;
            speakerGroup.rotation.x += (e.touches[0].clientY - previousMouse.y) * 0.01;
            previousMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        });
        
        renderer.domElement.addEventListener('touchend', () => isDragging = false);
        
        // Zoom
        renderer.domElement.addEventListener('wheel', (e) => {
            camera.position.z += e.deltaY * 0.01;
            camera.position.z = Math.max(8, Math.min(30, camera.position.z));
        });
        
        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // ===== PROCEDURAL AUDIO =====
        const playBtn = document.getElementById('playBtn');
        const vizBar = document.getElementById('vizBar');
        const bars = document.querySelectorAll('.bar');
        let isPlaying = false;
        let audioCtx = null;
        let musicInterval = null;
        
        const chords = [
            [261.63, 329.63, 392.00, 493.88],
            [293.66, 349.23, 440.00, 523.25],
            [392.00, 493.88, 587.33, 698.46],
            [349.23, 440.00, 523.25, 659.25],
            [220.00, 261.63, 329.63, 392.00],
        ];
        
        const bassNotes = [130.81, 146.83, 98.00, 116.54, 110.00];
        
        function createChillJazzChord() {
            if (!audioCtx) return;
            
            const chord = chords[Math.floor(Math.random() * chords.length)];
            const bass = bassNotes[Math.floor(Math.random() * bassNotes.length)];
            
            chord.forEach((freq) => {
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                const filter = audioCtx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                filter.type = 'lowpass';
                filter.frequency.value = 800;
                filter.Q.value = 1;
                
                gain.gain.setValueAtTime(0, audioCtx.currentTime);
                gain.gain.linearRampToValueAtTime(0.08, audioCtx.currentTime + 1);
                gain.gain.exponentialRampToValueAtTime(0.02, audioCtx.currentTime + 4);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(audioCtx.destination);
                
                osc.start();
                osc.stop(audioCtx.currentTime + 5);
            });
            
            const bassOsc = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            const bassFilter = audioCtx.createBiquadFilter();
            
            bassOsc.type = 'triangle';
            bassOsc.frequency.value = bass;
            
            bassFilter.type = 'lowpass';
            bassFilter.frequency.value = 400;
            
            bassGain.gain.setValueAtTime(0, audioCtx.currentTime);
            bassGain.gain.linearRampToValueAtTime(0.15, audioCtx.currentTime + 0.5);
            bassGain.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 3);
            
            bassOsc.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            
            bassOsc.start();
            bassOsc.stop(audioCtx.currentTime + 4);
        }
        
        async function startMusic() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
            createChillJazzChord();
            musicInterval = setInterval(() => {
                if (isPlaying && audioCtx) {
                    createChillJazzChord();
                }
            }, 3500 + Math.random() * 2000);
        }
        
        function stopMusic() {
            if (musicInterval) {
                clearInterval(musicInterval);
                musicInterval = null;
            }
            if (audioCtx) {
                audioCtx.close();
                audioCtx = null;
            }
        }
        
        playBtn.addEventListener('click', () => {
            if (isPlaying) {
                stopMusic();
                playBtn.textContent = '▶';
                playBtn.classList.remove('playing');
                vizBar.classList.remove('active');
            } else {
                startMusic();
                playBtn.textContent = '⏸';
                playBtn.classList.add('playing');
                vizBar.classList.add('active');
            }
            isPlaying = !isPlaying;
        });
        
        function animateViz() {
            if (isPlaying) {
                bars.forEach(bar => {
                    bar.style.height = (8 + Math.random() * 30) + 'px';
                });
            }
            setTimeout(animateViz, 150);
        }
        animateViz();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (autoRotate && !isDragging) {
                speakerGroup.rotation.y += 0.003;
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>